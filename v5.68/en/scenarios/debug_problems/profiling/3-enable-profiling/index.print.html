<!doctype html><html lang=en dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.125.5"><meta name=generator content="Relearn 6.4.0+tip"><meta name=description content="Let’s learn how to enable the memory and CPU profilers, verify their operation, and use the results in Splunk Observability Cloud to find out why our application startup is slow.
Update the application configuration We will need to pass additional configuration arguments to the Splunk OpenTelemetry Java agent in order to enable both profilers. The configuration is documented here in detail, but for now we just need the following settings:"><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="Enable AlwaysOn Profiling :: Splunk Observability Cloud Workshops"><meta name=twitter:description content="Let’s learn how to enable the memory and CPU profilers, verify their operation, and use the results in Splunk Observability Cloud to find out why our application startup is slow.
Update the application configuration We will need to pass additional configuration arguments to the Splunk OpenTelemetry Java agent in order to enable both profilers. The configuration is documented here in detail, but for now we just need the following settings:"><meta property="og:url" content="https://splunk.github.io/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/index.html"><meta property="og:site_name" content="Splunk Observability Cloud Workshops"><meta property="og:title" content="Enable AlwaysOn Profiling :: Splunk Observability Cloud Workshops"><meta property="og:description" content="Let’s learn how to enable the memory and CPU profilers, verify their operation, and use the results in Splunk Observability Cloud to find out why our application startup is slow.
Update the application configuration We will need to pass additional configuration arguments to the Splunk OpenTelemetry Java agent in order to enable both profilers. The configuration is documented here in detail, but for now we just need the following settings:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="Scenarios"><meta property="article:modified_time" content="2024-09-06T14:05:39-07:00"><meta itemprop=name content="Enable AlwaysOn Profiling :: Splunk Observability Cloud Workshops"><meta itemprop=description content="Let’s learn how to enable the memory and CPU profilers, verify their operation, and use the results in Splunk Observability Cloud to find out why our application startup is slow.
Update the application configuration We will need to pass additional configuration arguments to the Splunk OpenTelemetry Java agent in order to enable both profilers. The configuration is documented here in detail, but for now we just need the following settings:"><meta itemprop=dateModified content="2024-09-06T14:05:39-07:00"><meta itemprop=wordCount content="1109"><title>Enable AlwaysOn Profiling :: Splunk Observability Cloud Workshops</title>
<link href=https://splunk.github.io/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/index.html rel=canonical type=text/html title="Enable AlwaysOn Profiling :: Splunk Observability Cloud Workshops"><link href=/observability-workshop/v5.68/images/favicon.ico?1727454570 rel=icon type=image/x-icon sizes=any><link href=/observability-workshop/v5.68/css/fontawesome-all.min.css?1727454570 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/observability-workshop/v5.68/css/fontawesome-all.min.css?1727454570 rel=stylesheet></noscript><link href=/observability-workshop/v5.68/css/nucleus.css?1727454570 rel=stylesheet><link href=/observability-workshop/v5.68/css/auto-complete.css?1727454570 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/observability-workshop/v5.68/css/auto-complete.css?1727454570 rel=stylesheet></noscript><link href=/observability-workshop/v5.68/css/perfect-scrollbar.min.css?1727454570 rel=stylesheet><link href=/observability-workshop/v5.68/css/fonts.css?1727454570 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/observability-workshop/v5.68/css/fonts.css?1727454570 rel=stylesheet></noscript><link href=/observability-workshop/v5.68/css/theme.css?1727454570 rel=stylesheet><link href=/observability-workshop/v5.68/css/theme-splunk-light.css?1727454570 rel=stylesheet id=R-variant-style><link href=/observability-workshop/v5.68/css/chroma-relearn-light.css?1727454570 rel=stylesheet id=R-variant-chroma-style><link href=/observability-workshop/v5.68/css/variant.css?1727454570 rel=stylesheet><link href=/observability-workshop/v5.68/css/print.css?1727454570 rel=stylesheet media=print><link href=/observability-workshop/v5.68/css/format-print.css?1727454570 rel=stylesheet><script src=/observability-workshop/v5.68/js/variant.js?1727454570></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../../../../..",window.relearn.relBaseUri="../../../../../../..",window.relearn.absBaseUri="https://splunk.github.io/observability-workshop/v5.68",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.index_js_url="/observability-workshop/v5.68/en/index.search.js?1727454570",window.variants&&variants.init(["splunk-light","splunk-dark"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><script src=https://cdn.signalfx.com/o11y-gdi-rum/latest/splunk-otel-web.js crossorigin=anonymous></script><script src=https://cdn.signalfx.com/o11y-gdi-rum/latest/splunk-otel-web-session-recorder.js crossorigin=anonymous></script><script>SplunkRum.init({realm:"us1",rumAccessToken:"dp3FKraOS_wVhe-l7eCOsA",applicationName:"observability-workshop",deploymentEnvironment:"splunk.github.io",version:"1.0"}),SplunkSessionRecorder.init({app:"observability-workshop",realm:"us1",rumAccessToken:"dp3FKraOS_wVhe-l7eCOsA"})</script></script><style>:root{--MAIN-WIDTH-MAX:130rem;--MENU-WIDTH-L:23rem}</style></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/observability-workshop/v5.68/en/index.html><span itemprop=name>Splunk Observability Workshops</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/observability-workshop/v5.68/en/scenarios/index.html><span itemprop=name>Scenarios</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/observability-workshop/v5.68/en/scenarios/debug_problems/index.html><span itemprop=name>Debug Problems in Microservices</span></a><meta itemprop=position content="3">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/index.html><span itemprop=name>Profiling Workshop</span></a><meta itemprop=position content="4">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>3 Enable AlwaysOn Profiling</span><meta itemprop=position content="5"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/2-troubleshoot-game-startup/index.html title="Troubleshoot Game Startup (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/4-fix-app-startup-slowness/index.html title="Fix Application Startup Slowness (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=enable-alwayson-profiling>Enable AlwaysOn Profiling</h1><span class="badge cstyle primary badge-with-title"><span class=badge-title><i class="fa-fw fas fa-clock"></i></span><span class=badge-content>20 minutes</span>
</span>&nbsp;<p>Let&rsquo;s learn how to enable the memory and CPU profilers, verify their operation,
and use the results in Splunk Observability Cloud to find out why our application startup is slow.</p><h3 id=update-the-application-configuration>Update the application configuration</h3><p>We will need to pass additional configuration arguments to the Splunk OpenTelemetry Java agent in order to
enable both profilers. The configuration is <a href=https://docs.splunk.com/observability/en/gdi/get-data-in/application/java/instrumentation/instrument-java-application.html#activate-alwayson-profiling rel=external target=_blank>documented here</a>
in detail, but for now we just need the following settings:</p><div class="highlight wrap-code"><pre tabindex=0><code>SPLUNK_PROFILER_ENABLED=&#34;true&#34;
SPLUNK_PROFILER_MEMORY_ENABLED=&#34;true&#34;</code></pre></div><p>Since our application is deployed in Kubernetes, we can update the Kubernetes manifest file to set these environment variables. Open the <code>doorgame/doorgame.yaml</code> file for editing, and ensure the values of the following environment variables are set to &ldquo;true&rdquo;:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>SPLUNK_PROFILER_ENABLED</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;true&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>SPLUNK_PROFILER_MEMORY_ENABLED</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;true&#34;</span></span></span></code></pre></div><p>Next, let&rsquo;s redeploy the Door Game application by running the following command:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> workshop/profiling
</span></span><span class=line><span class=cl>kubectl apply -f doorgame/doorgame.yaml</span></span></code></pre></div><p>After a few seconds, a new pod will be deployed with the updated application settings.</p><h3 id=confirm-operation>Confirm operation</h3><p>To ensure the profiler is enabled, let&rsquo;s review the application logs with the following commands:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl logs -l <span class=nv>app</span><span class=o>=</span>doorgame --tail<span class=o>=</span><span class=m>100</span> <span class=p>|</span> grep JfrActivator</span></span></code></pre></div><p>You should see a line in the application log output that shows the profiler is active:</p><div class="highlight wrap-code"><pre tabindex=0><code class=language-log data-lang=log>[otel.javaagent 2024-02-05 19:01:12:416 +0000] [main] INFO com.splunk.opentelemetry.profiler.JfrActivator - Profiler is active.```</code></pre></div><p>This confirms that the profiler is enabled and sending data to the OpenTelemetry collector deployed in our Kubernetes cluster, which in turn sends profiling data to Splunk Observability Cloud.</p><h3 id=profiling-in-apm>Profiling in APM</h3><p>Visit <code>http://&lt;your IP address>:81</code> and play a few more rounds of The Door Game.</p><p>Then head back to Splunk Observability Cloud, click on APM, and click on the <code>doorgame</code> service at the bottom of the screen.</p><p>Click on &ldquo;Traces&rdquo; on the right-hand side to load traces for this service. Filter on traces involving the <code>doorgame</code> service and the <code>GET new-game</code> operation (since we&rsquo;re troubleshooting the game startup sequence):</p><p><a href=#R-image-579d02b429f3c2ef8794b6b54b21fd3a class=lightbox-link><img alt="New Game Traces" class="noborder lazy lightbox noshadow figure-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/new_game_traces.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-579d02b429f3c2ef8794b6b54b21fd3a><img alt="New Game Traces" class="noborder lazy lightbox noshadow lightbox-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/new_game_traces.png></a></p><p>Selecting one of these traces brings up the following screen:</p><p><a href=#R-image-8b671443772a6cabed2d86f9f24a58a5 class=lightbox-link><img alt="Trace with Call Stacks" class="noborder lazy lightbox noshadow figure-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/trace_with_call_stacks.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-8b671443772a6cabed2d86f9f24a58a5><img alt="Trace with Call Stacks" class="noborder lazy lightbox noshadow lightbox-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/trace_with_call_stacks.png></a></p><p>You can see that the spans now include &ldquo;Call Stacks&rdquo;, which is a result of us enabling CPU and memory profiling earlier.</p><p>Click on the span named <code>doorgame: SELECT doorgamedb</code>, then click on CPU stack traces on the right-hand side:</p><p><a href=#R-image-cf7f23ab16289fcca503f25a4600dd19 class=lightbox-link><img alt="Trace with CPU Call Stacks" class="noborder lazy lightbox noshadow figure-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/trace_with_cpu_call_stacks.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-cf7f23ab16289fcca503f25a4600dd19><img alt="Trace with CPU Call Stacks" class="noborder lazy lightbox noshadow lightbox-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/trace_with_cpu_call_stacks.png></a></p><p>This brings up the CPU call stacks captured by the profiler.</p><p>Let&rsquo;s open the AlwaysOn Profiler to review the CPU stack trace in more detail. We can do this by clicking on the <code>Span</code> link beside <code>View in AlwaysOn Profiler</code>:</p><p><a href=#R-image-f9ea9d725c424eb383bbe31b63023602 class=lightbox-link><img alt="Flamegraph and table" class="noborder lazy lightbox noshadow figure-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/flamegraph_and_table.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f9ea9d725c424eb383bbe31b63023602><img alt="Flamegraph and table" class="noborder lazy lightbox noshadow lightbox-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/flamegraph_and_table.png></a></p><p>The AlwaysOn Profiler includes both a table and a <a href=https://www.brendangregg.com/flamegraphs.html rel=external target=_blank>flamegraph</a>. Take some time to explore this view by doing some of the following:</p><ul><li>click a table item and notice the change in flamegraph</li><li>navigate the flamegraph by clicking on a stack frame to zoom in, and a parent frame to zoom out</li><li>add a search term like <code>splunk</code> or <code>jetty</code> to highlight some matching stack frames</li></ul><p>Let&rsquo;s have a closer look at the stack trace, starting with the <code>DoorGame.startNew</code> method (since we already know that it&rsquo;s the slowest part of the request)</p><div class="highlight wrap-code"><pre tabindex=0><code>com.splunk.profiling.workshop.DoorGame.startNew(DoorGame.java:24)
com.splunk.profiling.workshop.UserData.loadUserData(UserData.java:33)
com.mysql.cj.jdbc.StatementImpl.executeQuery(StatementImpl.java:1168)
com.mysql.cj.NativeSession.execSQL(NativeSession.java:655)
com.mysql.cj.protocol.a.NativeProtocol.sendQueryString(NativeProtocol.java:998)
com.mysql.cj.protocol.a.NativeProtocol.sendQueryPacket(NativeProtocol.java:1065)
com.mysql.cj.protocol.a.NativeProtocol.readAllResults(NativeProtocol.java:1715)
com.mysql.cj.protocol.a.NativeProtocol.read(NativeProtocol.java:1661)
com.mysql.cj.protocol.a.TextResultsetReader.read(TextResultsetReader.java:48)
com.mysql.cj.protocol.a.TextResultsetReader.read(TextResultsetReader.java:87)
com.mysql.cj.protocol.a.NativeProtocol.read(NativeProtocol.java:1648)
com.mysql.cj.protocol.a.ResultsetRowReader.read(ResultsetRowReader.java:42)
com.mysql.cj.protocol.a.ResultsetRowReader.read(ResultsetRowReader.java:75)
com.mysql.cj.protocol.a.MultiPacketReader.readMessage(MultiPacketReader.java:44)
com.mysql.cj.protocol.a.MultiPacketReader.readMessage(MultiPacketReader.java:66)
com.mysql.cj.protocol.a.TimeTrackingPacketReader.readMessage(TimeTrackingPacketReader.java:41)
com.mysql.cj.protocol.a.TimeTrackingPacketReader.readMessage(TimeTrackingPacketReader.java:62)
com.mysql.cj.protocol.a.SimplePacketReader.readMessage(SimplePacketReader.java:45)
com.mysql.cj.protocol.a.SimplePacketReader.readMessage(SimplePacketReader.java:102)
com.mysql.cj.protocol.a.SimplePacketReader.readMessageLocal(SimplePacketReader.java:137)
com.mysql.cj.protocol.FullReadInputStream.readFully(FullReadInputStream.java:64)
java.io.FilterInputStream.read(Unknown Source:0)
sun.security.ssl.SSLSocketImpl$AppInputStream.read(Unknown Source:0)
sun.security.ssl.SSLSocketImpl.readApplicationRecord(Unknown Source:0)
sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(Unknown Source:0)
sun.security.ssl.SSLSocketInputRecord.readHeader(Unknown Source:0)
sun.security.ssl.SSLSocketInputRecord.read(Unknown Source:0)
java.net.SocketInputStream.read(Unknown Source:0)
java.net.SocketInputStream.read(Unknown Source:0)
java.lang.ThreadLocal.get(Unknown Source:0)</code></pre></div><p>We can interpret the stack trace as follows:</p><ul><li>When starting a new Door Game, a call is made to load user data.</li><li>This results in executing a SQL query to load the user data (which is related to the slow SQL query we saw earlier).</li><li>We then see calls to read data in from the database.</li></ul><p>So, what does this all mean? It means that our application startup is slow since it&rsquo;s spending time loading user data. In fact, the profiler has told us the exact line of code where this happens:</p><div class="highlight wrap-code"><pre tabindex=0><code>com.splunk.profiling.workshop.UserData.loadUserData(UserData.java:33)</code></pre></div><p>Let&rsquo;s open the corresponding source file (<code>./doorgame/src/main/java/com/splunk/profiling/workshop/UserData.java</code>) and look at this code in more detail:</p><div class="highlight wrap-code"><pre tabindex=0><code>public class UserData {

    static final String DB_URL = &#34;jdbc:mysql://mysql/DoorGameDB&#34;;
    static final String USER = &#34;root&#34;;
    static final String PASS = System.getenv(&#34;MYSQL_ROOT_PASSWORD&#34;);
    static final String SELECT_QUERY = &#34;select * FROM DoorGameDB.Users, DoorGameDB.Organizations&#34;;

    HashMap&lt;String, User&gt; users;

    public UserData() {
        users = new HashMap&lt;String, User&gt;();
    }

    public void loadUserData() {

        // Load user data from the database and store it in a map
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;

        try{
            conn = DriverManager.getConnection(DB_URL, USER, PASS);
            stmt = conn.createStatement();
            rs = stmt.executeQuery(SELECT_QUERY);
            while (rs.next()) {
                User user = new User(rs.getString(&#34;UserId&#34;), rs.getString(&#34;FirstName&#34;), rs.getString(&#34;LastName&#34;));
                users.put(rs.getString(&#34;UserId&#34;), user);
            }</code></pre></div><p>Here we can see the application logic in action. It establishes a connection to the database, then executes the SQL query we saw earlier:</p><div class="highlight wrap-code"><pre tabindex=0><code>select * FROM DoorGameDB.Users, DoorGameDB.Organizations</code></pre></div><p>It then loops through each of the results, and loads each user into a <code>HashMap</code> object, which is a collection of <code>User</code> objects.</p><p>We have a good understanding of why the game startup sequence is so slow, but how do we fix it?</p><p>For more clues, let&rsquo;s have a look at the other part of AlwaysOn Profiling: memory profiling. To do this, click on the <code>Memory</code> tab in AlwaysOn profiling:</p><p><a href=#R-image-03aaf0e41d8ea54241b6f86bd1edba1b class=lightbox-link><img alt="Memory Profiling" class="noborder lazy lightbox noshadow figure-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/memory_profiling.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-03aaf0e41d8ea54241b6f86bd1edba1b><img alt="Memory Profiling" class="noborder lazy lightbox noshadow lightbox-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/memory_profiling.png></a></p><p>At the top of this view, we can see how much heap memory our application is using, the heap memory allocation rate, and garbage collection activity.</p><p>We can see that our application is using about 400 MB out of the max 1 GB heap size, which seems excessive for such a simple application. We can also see that some garbage collection occurred, which caused our application to pause (and probably annoyed those wanting to play the Game Door).</p><p>At the bottom of the screen, which can see which methods in our Java application code are associated with the most heap memory usage. Click on the first item in the list to show the Memory Allocation Stack Traces associated with the <code>java.util.Arrays.copyOf</code> method specifically:</p><p><a href=#R-image-e4585141b311924c4983be898f0e5df7 class=lightbox-link><img alt="Memory Allocation Stack Traces" class="noborder lazy lightbox noshadow figure-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/memory_allocation_stack_traces.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e4585141b311924c4983be898f0e5df7><img alt="Memory Allocation Stack Traces" class="noborder lazy lightbox noshadow lightbox-image" loading=lazy src=/observability-workshop/v5.68/en/scenarios/debug_problems/profiling/3-enable-profiling/../images/memory_allocation_stack_traces.png></a></p><p>With help from the profiler, we can see that the <code>loadUserData</code> method not only consumes excessive CPU time, but it also consumes excessive memory when storing the user data in the <code>HashMap</code> collection object.</p><h2 id=what-did-we-accomplish>What did we accomplish?</h2><p>We&rsquo;ve come a long way already!</p><ul><li>We learned how to enable the profiler in the Splunk OpenTelemetry Java instrumentation agent.</li><li>We learned how to verify in the agent output that the profiler is enabled.</li><li>We have explored several profiling related workflows in APM:<ul><li>How to navigate to AlwaysOn Profiling from the troubleshooting view</li><li>How to explore the flamegraph and method call duration table through navigation and filtering</li><li>How to identify when a span has sampled call stacks associated with it</li><li>How to explore heap utilization and garbage collection activity</li><li>How to view memory allocation stack traces for a particular method</li></ul></li></ul><p>In the next section, we&rsquo;ll apply a fix to our application to resolve the slow startup performance.</p><footer class=footline><span class="badge cstyle note badge-with-title"><span class=badge-title class=text-muted>Last Modified
</span><span class=badge-content>Sep 6, 2024</span></span></footer></article></div></main></div><script src=/observability-workshop/v5.68/js/clipboard.min.js?1727454570 defer></script><script src=/observability-workshop/v5.68/js/perfect-scrollbar.min.js?1727454570 defer></script><script src=/observability-workshop/v5.68/js/theme.js?1727454570 defer></script></body></html>