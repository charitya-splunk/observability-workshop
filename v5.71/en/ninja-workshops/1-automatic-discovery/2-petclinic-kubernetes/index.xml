<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring PetClinic SpringBoot Based Microservices On Kubernetes :: Splunk Observability Cloud Workshops</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/index.html</link><description>Learn how to enable automatic discovery and configuration for your Java-based application running in Kubernetes. Experience real-time monitoring to help you maximize application behavior with end-to-end visibility.</description><generator>Hugo</generator><language>en</language><atom:link href="https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Architecture</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/1-architecture/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/1-architecture/index.html</guid><description>The Spring PetClinic Java application is a simple microservices application that consists of a frontend and backend services. The frontend service is a Spring Boot application that serves a web interface to interact with the backend services. The backend services are Spring Boot applications that serve RESTful API’s to interact with a MySQL database.
By the end of this workshop, you will have a better understanding of how to enable automatic discovery and configuration for your Java-based applications running in Kubernetes.</description></item><item><title>Preparation of the Workshop instance</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/2-preparation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/2-preparation/index.html</guid><description>The instructor will provide you with the login information for the instance that we will be using during the workshop.
When you first log into your instance, you will be greeted by the Splunk Logo as shown below. If you have any issues connecting to your workshop instance then please reach out to your Instructor.
$ ssh -p 2222 splunk@&lt;ip-address> ███████╗██████╗ ██╗ ██╗ ██╗███╗ ██╗██╗ ██╗ ██╗ ██╔════╝██╔══██╗██║ ██║ ██║████╗ ██║██║ ██╔╝ ╚██╗ ███████╗██████╔╝██║ ██║ ██║██╔██╗ ██║█████╔╝ ╚██╗ ╚════██║██╔═══╝ ██║ ██║ ██║██║╚██╗██║██╔═██╗ ██╔╝ ███████║██║ ███████╗╚██████╔╝██║ ╚████║██║ ██╗ ██╔╝ ╚══════╝╚═╝ ╚══════╝ ╚═════╝ ╚═╝ ╚═══╝╚═╝ ╚═╝ ╚═╝ Last login: Mon Feb 5 11:04:54 2024 from [Redacted] Waiting for cloud-init status... Your instance is ready! splunk@show-no-config-i-0d1b29d967cb2e6ff:~$ To ensure your instance is configured correctly, we need to confirm that the required environment variables for this workshop are set correctly. In your terminal run the following script and check that the environment variables are present and set with actual valid values:</description></item><item><title>Verify Kubernetes Cluster metrics</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/3-verify-setup/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/3-verify-setup/index.html</guid><description>Once the installation has been completed, you can log in to Splunk Observability Cloud and verify that the metrics are flowing in from your Kubernetes cluster.
From the left-hand menu click on Infrastructure and select Kubernetes, then select the Kubernetes nodes pane. Once you are in the Kubernetes nodes view, change the Time filter from -4h to the last 15 minutes (-15m) to focus on the latest data.</description></item><item><title>Setting up automatic discovery and configuration for APM</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/4-apm/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/4-apm/index.html</guid><description>In this section we will enable automatic discovery and configuration for the Java services running in Kubernetes. This means that the OpenTelemetry Collector will look for Pod annotations that indicate that the Java application should be instrumented with the Splunk OpenTelemetry Java agent. This will allow us to get traces, spans, and profiling data from the Java services running on the cluster.
automatic discovery and configuration It is important to understand that automatic discovery and configuration is designed to get trace, span &amp; profiling data out of your application, without requiring code changes or recompilation.</description></item><item><title>APM Features</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/5-traces/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/5-traces/index.html</guid><description>As we have seen in the previous section, once you enable automatic discovery and configuration on your services, traces are sent to Splunk Observability Cloud.
With these traces, Splunk will automatically generate Service Maps and RED Metrics. These are the first steps in understanding the behavior of your services and how they interact with each other.
In this next section, we are going to examine the traces themselves and what information they provide to help you understand the behavior of your services all without touching your code.</description></item><item><title>Always-On Profiling &amp; DB Query Performance</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/6-profiling-db-query/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/6-profiling-db-query/index.html</guid><description>As we have seen in the previous chapter, you can trace your interactions between the various services using APM without touching your code, which will allow you to identify issues faster.
However, besides tracing automatic discovery and configuration offers additional features out of the box that can help you find issues even faster. In this section we are going to look at two of them:
Always-on Profiling and Java Metrics Database Query Performance If you want to dive deeper into Always-on Profiling or DB-Query performance, we have a separate Ninja Workshop called Debug Problems in Microservices that you can follow.</description></item><item><title>Log Observer</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/7-log-observer-connect/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/7-log-observer-connect/index.html</guid><description>Up until this point, there have been no code changes, yet tracing, profiling and Database Query Performance data is being sent to Splunk Observability Cloud.
Next we will work with the Splunk Log Observer to the mix to obtain log data from the Spring PetClinic application.
The Splunk OpenTelemetry Collector automatically collects logs from the Spring PetClinic application and sends them to Splunk Observability Cloud using the OTLP exporter, annotating the log events with trace_id, span_id and trace flags.</description></item><item><title>Real User Monitoring</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/8-rum/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/8-rum/index.html</guid><description>To enable Real User Monitoring (RUM) instrumentation for an application, you need to add the Open Telemetry Javascript https://github.com/signalfx/splunk-otel-js-web snippet to the code base.
The Spring PetClinic application uses a single index HTML page, that is reused across all views of the application. This is the perfect location to insert the Splunk RUM instrumentation library as it will be loaded for all pages automatically.
The api-gateway service is already running the instrumentation and sending RUM traces to Splunk Observability Cloud and we will review the data in the next section.</description></item><item><title>Workshop Wrap-up 🎁</title><link>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/9-wrap-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://splunk.github.io/observability-workshop/v5.71/en/ninja-workshops/1-automatic-discovery/2-petclinic-kubernetes/9-wrap-up/index.html</guid><description>Congratulations, you have completed the Get the Most Out of Your Existing Kubernetes Java Applications Using Automatic Discovery and Configuration With OpenTelemetry. Today, you have become familiar with how easy it is to add tracing, Code Profiling and Database Query Performance to your existing Java application in Kubernetes to immediately improve the observability of your applications and infrastructure.</description></item></channel></rss>